'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDirection;

var _position = require('./position');

function checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) {
  var targetRect = target.getBoundingClientRect();
  var deadSpace = Math.min(targetRect.left, document.documentElement.clientWidth - targetRect.right);

  return tip.offsetWidth + target.offsetWidth + distance + bodyPadding + deadSpace < document.documentElement.clientWidth;
} /**
   * Checks the intended tip direction and falls back if not enough space
   */


function checkTargetFullyVisible(target) {
  var bottomOverhang = target.getBoundingClientRect().bottom > window.innerHeight;
  var topOverhang = target.getBoundingClientRect().top < 0;

  return !bottomOverhang && !topOverhang;
}

function checkForArrowOverhang(tip, arrowStyles, bodyPadding) {
  var scrollLeft = (0, _position.getScrollLeft)();
  var hasLeftClearance = arrowStyles.left - scrollLeft > bodyPadding;
  var hasRightClearance = arrowStyles.left + _position.arrowSize * 2 < scrollLeft + document.documentElement.clientWidth - bodyPadding;

  return !hasLeftClearance || !hasRightClearance;
}

function getDirection(currentDirection, tip, target, distance, bodyPadding, arrowStyles, recursive) {
  // can't switch until target is rendered
  if (!target) {
    return currentDirection;
  }

  var targetRect = target.getBoundingClientRect();

  switch (currentDirection) {
    case 'right':
      // if the window is not wide enough try top (which falls back to down)
      if (!checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) || !checkTargetFullyVisible(target)) {
        return getDirection('up', tip, target, distance, bodyPadding, arrowStyles, true);
      }

      if (document.documentElement.clientWidth - targetRect.right < tip.offsetWidth + distance + bodyPadding) {
        return 'left';
      }

      return 'right';

    case 'left':
      // if the window is not wide enough try top (which falls back to down)
      if (!checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) || !checkTargetFullyVisible(target)) {
        return getDirection('up', tip, target, distance, bodyPadding, arrowStyles, true);
      }

      if (targetRect.left < tip.offsetWidth + distance + bodyPadding) {
        return 'right';
      }

      return 'left';

    case 'up':
      if (!recursive && arrowStyles && checkForArrowOverhang(tip, arrowStyles, bodyPadding)) {
        return getDirection('left', tip, target, distance, bodyPadding, arrowStyles, true);
      }

      if (targetRect.top < tip.offsetHeight + distance + bodyPadding) {
        return 'down';
      }

      return 'up';

    case 'down':
    default:
      if (!recursive && arrowStyles && checkForArrowOverhang(tip, arrowStyles, bodyPadding)) {
        return getDirection('right', tip, target, distance, bodyPadding, arrowStyles, true);
      }

      if (window.innerHeight - targetRect.bottom < tip.offsetHeight + distance + bodyPadding) {
        return 'up';
      }

      return 'down';
  }
}